# Tools 
In the following, some tools for backend development are introduced



# Data Serialization
## JackSON
**Problem to Solve - JSON:** How to work with JSON data in Java, including serialization and deserialization?

**Solution - JSON Parser:** A library that can handle the conversion between Java objects and JSON effortlessly is required.

### About Jackson
**Definition:** Jackson is a high-performance ***JSON processing library*** for Java. It provides a way to convert between Java objects and JSON data, i.e., ***serialization and deserialization***.

**Syntax:**
| Annotation         | Purpose                                                |
|-------------------- |------------------------------------------------------- |
| `@JsonProperty`    | Specifies the JSON property name for a Java field or method. |
| `@JsonIgnore`      | Excludes a Java field or method from JSON serialization or deserialization. |
| `@JsonInclude`     | Defines rules for including or ignoring properties in JSON serialization. |
| `@JsonCreator`     | Indicates a constructor or factory method for deserialization. |
| `@JsonFormat`      | Specifies a date or number format for serialization or deserialization. |

<br>

**Example (Code):** 
```java
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class Employee {
    @JsonProperty("employeeId")
    private int id;
    private String firstName;
    private String lastName;

    public Employee(int id, String firstName, String lastName) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public int getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public static void main(String[] args) throws JsonProcessingException {
        // Create an Employee object
        Employee employee = new Employee(12345, "John", "Doe");

        // Create an ObjectMapper
        ObjectMapper objectMapper = new ObjectMapper();

        //==================================
        // SERIALIZE Employee object to JSON
        String json = objectMapper.writeValueAsString(employee);

        System.out.println("Serialized JSON: " + json);
            > Output:
            > {
            >   "employeeId": 12345,   // Renamed from "id" using @JsonProperty
            >   "firstName": "John",
            >   "lastName": "Doe"
            > }
            
        //==================================
        // DE-SERIALIZE JSON to Employee object
        Employee deserialized = objectMapper.readValue(json, Employee.class);

        System.out.println("Deserialized Employee: " + 
                    deserialized.getFirstName() + " " + 
                    deserialized.getLastName());
            > Output: 
            > "Deserialized Employee: John Doe"

    }
}
```

## Protobuf (Protocoll Buffer)
**Problem to Solve:** How to send information across network/internet?
**Solution:** Use a ***Data Format*** like, `XML`, `JSON`, `Protobuf`.

### About Protobuf
**Definition:** Protocol Buffers (protobuf) is a method for serializing structured data in a ***binary format***. 
- **Serialization:** protobuf can serialize from and deserialize to almost any programming lanugage
- **Storage:** storing serialized data in protobuf format is ***byte-efficient*** - around 100% byte reduction compared to JSON
- **Strong Typing:** it declares and uses ***strong typing***, resulting in low error rate


**Example (Code):** The following example illustrates how to:
- define a class/schema
- use generated code to create an object
- deserialize
- serialize

1. **Schema/Class Definition:** In a proto file `person.proto` define a class/schema 
    ```protobuf
    syntax = "proto3";
    message Person {
        string name = 1;
        int32 age = 2;
    }
    ```
2. **Create autogenerated (Java) class:** Based on this proto file, autogenerate code
    ```
    protoc --java_out=. person.proto
    ```
3. **Load classes:** Based on autogenerated class(es), create new objects
    ```java
    import com.example.PersonProto.Person;

    // Create a Person object
    Person person = Person.newBuilder()
        .setName("John Doe")
        .setAge(30)
        .build();
    ```

4. **De/Serialization:** Now, de/serialization can be performed
    ```java

    // Serialize: object --> bytes
    byte[] serializedData = person.toByteArray();

    // Deserialize: bytes --> object
    Person deserializedPerson = Person.parseFrom(serializedData);
    ```

## Webflux 
**Problem to Solve - Concurrent Requests:** When dealing with *lots of concurrent request*, these request are often handeled *inefficient*, resulting in (1) resource consumption, (2) blocking, (3) decreased responsiveness in web applications.

**Soluton - Reactive Programming:** The paradigm of *Reactive Programming* solves the problem of handeling *concurrent requests* by introducing principles of non-blocking, event-driven, and asynchronous operations. 

### About Webflux
**Definition:**  Webflux is a implementation of the *Reactive Programming* Paradigm. It is a programming framework integrated in the *Spring* ecosystem designed to efficientely manage concurrent requests. 


The following example illustrates how a `@RestController` handels the same task - *returning User based in id* - using different techniques/syntaxes.

**Syntax Comparision:**

| Syntax    | Method Type                       | Blocking    | Description                                                                                   | Streaming | IoT |
|-----------|-----------------------------------|-------------|-----------------------------------------------------------------------------------------------|-----------|---------------------------------------|
| Java      | `User getUser()`                   | High        | Synchronous; blocking until the result is available.   | No        | No                                    |
| Java      | `Future<User> getUser()`           | Low         | Asynchronous; waiting for the result without blocking the main thread. | No        | No                                    |
| Java      | `CompletableFuture<User> getUser()` | Low         | Asynchronous;  similar to `Future`, but more control for asynchronous operations. | No        | No                                    |
| WebFlux   | `Mono<User> getUser()`             | Very Low    | Reactive programming representing a potentially asynchronous operation with non-blocking capabilities. | No        | Yes                                   |
| WebFlux   | `Flux<User> getUser()`             | Very Low    | Reactive programming; handling sequences of data/events. | Yes       | Yes                                   |

<br>

**Example (Code):**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;


import java.util.concurrent.Future;
import java.util.concurrent.CompletableFuture;


@RestController
public class BlockingUserController {

    @Autowired
    private UserRepository repository;

    // BLOCKING
    @GetMapping("/get/user/{id}")
    public User getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // BLOCKING AFTER 1s
    @GetMapping("/get/user/{id}")
    public Future<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // NON BLOCKING
    @GetMapping("/get/user/semi-blocking/{id}")
    public CompletableFuture<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // WEBFLUX: MONO
    @GetMapping("/get/user/mono/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // WEBFLUX: FLUX (list)
    @GetMapping("/get/user/flux/{id}")
    public Flux<User> getAllUsers() {
        return repository.findAll();
    }
}
```


## OAuth2
**Problem to Solve - Third Parties** How to How securely and conveniently ***grant third-party applications access*** to user data and resources without exposing login credentials and while ensuring user consent?

**Solution - Authorization Framework**  A standardized framework for ***authorization*** is required. It should provide mechanisms for users to 
- grant limited permissions to third-party applications
- offer token-based authentication
- enable fine-grained access control. 

Additionally, it should be extensible, interoperable across various service providers and applications, and user-friendly. 

### About OAuth2
**Defintion:** OAuth2 is an open standard and ***framework for secure authorization***. It provides a method for users to *grant third-party applications limited access* to their resources without sharing their login credentials. OAuth2 focuses on ***granting access, not verifying identity***. It defines a set of protocols and mechanisms for this purpose.

**OAuth1.0 vs OAuth2:** OAuth (OAuth 1.0) and OAuth2 are often compared, but they serve different purposes and have distinct characteristics:

- **OAuth (OAuth 1.0)**: Focused on both authentication and authorization, often involving cryptographic signatures, which made it more complex.
- **OAuth2**: Primarily designed for authorization, not authentication, with a simplified and more user-friendly approach, offering various grant types for different use cases.

**Example (Code - OAuth2-client in Spring Boot):** There is a Spring Boot plugin `oauth2-client` which can be used to easily implement *OAuth2*. 

No example here, better do a mini-project or watch a video.


## Lombok
**Problem to Solve - Boilerplate Code:** How to reduce verbosity of Java code, eliminate boilerplate code while maintaining code readability and maintainability?

**Solution - Code Generation:** Automatic generation of commonly used code structures which should enable developers to focus on their application's core logic while making the codebase more concise and readable.

### About Lombok
**Definition:** Lombok is a Java library that simplifies Java development by reducing boilerplate code through the use of ***annotations***. It enables ***automatic code generation*** during compilation, helping developers write cleaner and more concise Java code.

**Syntax:** The table lists the most important *Lombok* annotarors:
| Annotation         | Purpose                                                  |
|-------------------- |---------------------------------------------------------|
| `@Data`             | Generates getters, setters, `equals`, `hashCode`, and `toString` methods for a class. |
| `@Getter`           | Generates getter methods for class fields.              |
| `@Setter`           | Generates setter methods for class fields.              |
| `@NoArgsConstructor` | Generates a no-argument constructor.                    |
| `@AllArgsConstructor` | Generates a constructor with all class fields as arguments. |
| `@Builder`          | Provides a builder pattern for creating instances of the class. |

**Example (Code, Java Spring):** The following example shows a Java code with and without Lombok which illustrates how much boilerplate code can be saved by using *Lombok*.

1. **Lombok**
    ```java
    import lombok.Data;

    @Data // Lombok Annotation!
    public class User {
        private Long id;
        private String firstName;
        private String lastName;
    }
    ```
2. **Without Lombok**
    ```java
    public class User {
        private Long id;
        private String firstName;
        private String lastName;

        public User() {
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getFirstName() {
            return firstName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            User user = (User) o;
            return Objects.equals(id, user.id) &&
                Objects.equals(firstName, user.firstName) &&
                Objects.equals(lastName, user.lastName);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, firstName, lastName);
        }

        @Override
        public String toString() {
            return "User{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                '}';
        }
    }
    ```




