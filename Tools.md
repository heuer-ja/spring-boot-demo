# Tools 
In the following, some tools for backend development are introduced



# Data Serialization
## JackSON
**Problem to Solve - JSON:** How to work with JSON data in Java, including serialization and deserialization?

**Solution - JSON Parser:** A library that can handle the conversion between Java objects and JSON effortlessly is required.

### About Jackson
**Definition:** Jackson is a high-performance ***JSON processing library*** for Java. It provides a way to convert between Java objects and JSON data, i.e., ***serialization and deserialization***.

**Syntax:**

| Annotation      | Purpose                                                                     |
|-----------------|-----------------------------------------------------------------------------|
| `@JsonProperty` | Specifies the JSON property name for a Java field or method.                |
| `@JsonIgnore`   | Excludes a Java field or method from JSON serialization or deserialization. |
| `@JsonInclude`  | Defines rules for including or ignoring properties in JSON serialization.   |
| `@JsonCreator`  | Indicates a constructor or factory method for deserialization.              |
| `@JsonFormat`   | Specifies a date or number format for serialization or deserialization.     |

<br>

**Example (Code):** 
```java
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class Employee {
    @JsonProperty("employeeId")
    private int id;
    private String firstName;
    private String lastName;

    public Employee(int id, String firstName, String lastName) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public int getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public static void main(String[] args) throws JsonProcessingException {
        // Create an Employee object
        Employee employee = new Employee(12345, "John", "Doe");

        // Create an ObjectMapper
        ObjectMapper objectMapper = new ObjectMapper();

        //==================================
        // SERIALIZE Employee object to JSON
        String json = objectMapper.writeValueAsString(employee);

        System.out.println("Serialized JSON: " + json);
            > Output:
            > {
            >   "employeeId": 12345,   // Renamed from "id" using @JsonProperty
            >   "firstName": "John",
            >   "lastName": "Doe"
            > }
            
        //==================================
        // DE-SERIALIZE JSON to Employee object
        Employee deserialized = objectMapper.readValue(json, Employee.class);

        System.out.println("Deserialized Employee: " + 
                    deserialized.getFirstName() + " " + 
                    deserialized.getLastName());
            > Output: 
            > "Deserialized Employee: John Doe"

    }
}
```

## Protobuf (Protocoll Buffer)
**Problem to Solve:** How to send information across network/internet?
**Solution:** Use a ***Data Format*** like, `XML`, `JSON`, `Protobuf`.

### About Protobuf
**Definition:** Protocol Buffers (protobuf) is a method for serializing structured data in a ***binary format***. 
- **Serialization:** protobuf can serialize from and deserialize to almost any programming language
- **Storage:** storing serialized data in protobuf format is ***byte-efficient*** - around 100% byte reduction compared to JSON
- **Strong Typing:** it declares and uses ***strong typing***, resulting in low error rate


**Example (Code):** The following example illustrates how to:
- define a class/schema
- use generated code to create an object
- deserialize
- serialize

1. **Schema/Class Definition:** In a proto file `person.proto` define a class/schema 
    ```protobuf
    syntax = "proto3";
    message Person {
        string name = 1;
        int32 age = 2;
    }
    ```
2. **Create autogenerated (Java) class:** Based on this proto file, autogenerate code
    ```
    protoc --java_out=. person.proto
    ```
3. **Load classes:** Based on autogenerated class(es), create new objects
    ```java
    import com.example.PersonProto.Person;

    // Create a Person object
    Person person = Person.newBuilder()
        .setName("John Doe")
        .setAge(30)
        .build();
    ```

4. **De/Serialization:** Now, de/serialization can be performed
    ```java

    // Serialize: object --> bytes
    byte[] serializedData = person.toByteArray();

    // Deserialize: bytes --> object
    Person deserializedPerson = Person.parseFrom(serializedData);
    ```

## Webflux 
**Problem to Solve - Concurrent Requests:** When dealing with *lots of concurrent request*, these request are often handeled *inefficient*, resulting in (1) resource consumption, (2) blocking, (3) decreased responsiveness in web applications.

**Soluton - Reactive Programming:** The paradigm of *Reactive Programming* solves the problem of handeling *concurrent requests* by introducing principles of non-blocking, event-driven, and asynchronous operations. 

### About Webflux
**Definition:**  Webflux is a implementation of the *Reactive Programming* Paradigm. It is a programming framework integrated in the *Spring* ecosystem designed to efficientely manage concurrent requests. 


The following example illustrates how a `@RestController` handels the same task - *returning User based in id* - using different techniques/syntaxes.

**Syntax Comparision:**

| Syntax  | Method Type                         | Blocking | Description                                                                                            | Streaming | IoT |
|---------|-------------------------------------|----------|--------------------------------------------------------------------------------------------------------|-----------|-----|
| Java    | `User getUser()`                    | High     | Synchronous; blocking until the result is available.                                                   | No        | No  |
| Java    | `Future<User> getUser()`            | Low      | Asynchronous; waiting for the result without blocking the main thread.                                 | No        | No  |
| Java    | `CompletableFuture<User> getUser()` | Low      | Asynchronous;  similar to `Future`, but more control for asynchronous operations.                      | No        | No  |
| WebFlux | `Mono<User> getUser()`              | Very Low | Reactive programming representing a potentially asynchronous operation with non-blocking capabilities. | No        | Yes |
| WebFlux | `Flux<User> getUser()`              | Very Low | Reactive programming; handling sequences of data/events.                                               | Yes       | Yes |

<br>

**Example (Code):**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;


import java.util.concurrent.Future;
import java.util.concurrent.CompletableFuture;


@RestController
public class BlockingUserController {

    @Autowired
    private UserRepository repository;

    // BLOCKING
    @GetMapping("/get/user/{id}")
    public User getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // BLOCKING AFTER 1s
    @GetMapping("/get/user/{id}")
    public Future<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // NON BLOCKING
    @GetMapping("/get/user/semi-blocking/{id}")
    public CompletableFuture<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // WEBFLUX: MONO
    @GetMapping("/get/user/mono/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        return repository.findById(id);
    }

    // WEBFLUX: FLUX (list)
    @GetMapping("/get/user/flux/{id}")
    public Flux<User> getAllUsers() {
        return repository.findAll();
    }
}
```



# Other
## OAuth2
**Problem to Solve - Third Parties** How to How securely and conveniently ***grant third-party applications access*** to user data and resources without exposing login credentials and while ensuring user consent?

**Solution - Authorization Framework**  A standardized framework for ***authorization*** is required. It should provide mechanisms for users to 
- grant limited permissions to third-party applications
- offer token-based authentication
- enable fine-grained access control. 

Additionally, it should be extensible, interoperable across various service providers and applications, and user-friendly. 

### About OAuth2
**Definition:** OAuth2 is an open standard and ***framework for secure authorization***. It provides a method for users to *grant third-party applications limited access* to their resources without sharing their login credentials. OAuth2 focuses on ***granting access, not verifying identity***. It defines a set of protocols and mechanisms for this purpose.

**OAuth1.0 vs OAuth2:** OAuth (OAuth 1.0) and OAuth2 are often compared, but they serve different purposes and have distinct characteristics:

- **OAuth (OAuth 1.0)**: Focused on both authentication and authorization, often involving cryptographic signatures, which made it more complex.
- **OAuth2**: Primarily designed for authorization, not authentication, with a simplified and more user-friendly approach, offering various grant types for different use cases.

**Example (Code - OAuth2-client in Spring Boot):** There is a Spring Boot plugin `oauth2-client` which can be used to easily implement *OAuth2*. 

No example here, better do a mini-project or watch a video.

## Lombok
**Problem to Solve - Boilerplate Code:** How to reduce verbosity of Java code, eliminate boilerplate code while maintaining code readability and maintainability?

**Solution - Code Generation:** Automatic generation of commonly used code structures which should enable developers to focus on their application's core logic while making the codebase more concise and readable.

### About Lombok
**Definition:** Lombok is a Java library that simplifies Java development by reducing boilerplate code through the use of ***annotations***. It enables ***automatic code generation*** during compilation, helping developers write cleaner and more concise Java code.

**Syntax:** The table lists the most important *Lombok* annotators:

| Annotation            | Purpose                                                                               |
|-----------------------|---------------------------------------------------------------------------------------|
| `@Data`               | Generates getters, setters, `equals`, `hashCode`, and `toString` methods for a class. |
| `@Getter`             | Generates getter methods for class fields.                                            |
| `@Setter`             | Generates setter methods for class fields.                                            |
| `@NoArgsConstructor`  | Generates a no-argument constructor.                                                  |
| `@AllArgsConstructor` | Generates a constructor with all class fields as arguments.                           |
| `@Builder`            | Provides a builder pattern for creating instances of the class.                       |

**Example (Code, Java Spring):** The following example shows a Java code with and without Lombok which illustrates how much boilerplate code can be saved by using *Lombok*.

1. **Lombok**
    ```java
    import lombok.Data;

    @Data // Lombok Annotation!
    public class User {
        private Long id;
        private String firstName;
        private String lastName;
    }
    ```
2. **Without Lombok**
    ```java
    public class User {
        private Long id;
        private String firstName;
        private String lastName;

        public User() {
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getFirstName() {
            return firstName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            User user = (User) o;
            return Objects.equals(id, user.id) &&
                Objects.equals(firstName, user.firstName) &&
                Objects.equals(lastName, user.lastName);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, firstName, lastName);
        }

        @Override
        public String toString() {
            return "User{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                '}';
        }
    }
    ```

## OpenAPI & Swagger
**Problem to Solve - Misunderstanding of RESTful API Functionality:** How to know what  ***different RESTful APIs*** are capable of in terms of endpoints, functionality, return types, etc.? 

**Solution - Standardized RESTful API Documentation:** Introduce a consistent and standardized way to document a RESTful API's functionality resulting in no misunderstanding, better collaboration, and enhanced integration.

### About OpenAPI
**Definition:** OpenAPI serves as a standardized approach for describing and documenting RESTful APIs. It provides a machine-readable format that specifies API endpoints, request and response structures, parameters, and authentication methods.

**Formats:** Written in `YAML` (preferred) or `JSON`. 

### Swagger
**Definition:** Swagger is a practical ***tool*** and user interface ***(UI)*** for documenting RESTful APIs ***following OpenAPI Specification***.

**Concepts:**
- **API Design & Documentation:** Swagger tools are primarily used for designing API endpoints, defining request and response structures, and specifying authentication methods. 
- **Code Generation:** Swagger enables the automatic generation of client SDKs, server stubs, and interactive documentation from API specifications.

### Developing OpenAPI Specification

**Design-first vs. Code-first:** When developing OpenAPI specification, developers can use one of two ways to realize it.

- **Design-first:** First, use swagger to specify/document API before any code is written. Then, create the code and satisfy specification.
- **Code-first:** Code first and auto-generate YAML/JSON-based OpenAPI specification based on code. 

**YAML vs. JSON:** Both, `YAML` and `JSON` can be used to define the OpenAPI specification. However, YAML is preferred due to its shorter syntax. 

1. Example YAML Specification:
    ```yaml
    openapi: 3.0.0
    info:
      title: Sample API
      version: 1.0.0
    paths:
      /hello:
        get:
          summary: Get a friendly greeting
          responses:
            '200':
                description: A successful response
                content:
                  application/json:
                    schema:
                      type: string
    ```
2. Example JSON:
    ```json
    {
      "openapi": "3.0.0",
      "info": {
        "title": "Sample API",
        "version": "1.0.0"
      },
      "paths": {
        "/hello": {
          "get": {
            "summary": "Get a friendly greeting",
            "responses": {
              "200": {
                "description": "A successful response",
                "content": {
                  "application/json": {
                    "schema": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ```



# Testing
## JUnit5
**Problem - Changes in Code** How to ensure that software functions correctly, especially when changes are made to the code or new features are added?

**Solution - Unit Testing and TDD:** 
- **Unit Testing:** Unit testing is a ***software testing technique*** where individual components or units of a software application are tested in isolation. It allows to verify that ***each part*** of the codebase functions correctly and meets its specifications. By writing tests for specific units, issues are detected early in the development process, making debugging and maintenance more manageable.

- **Test-Driven Development (TDD):** TDD is a ***development approach*** that promotes ***writing tests before*** writing the actual code. This approach consists of 
  1. creating failing tests that describe the desired behavior
  2. writing code to make the tests pass
  3. refactoring the code for improved quality.

### JUnit
**JUnit:** JUnit is a widely used ***testing framework*** for Java applications. It provides a structured and organized way to write and execute unit tests.

**JUnit5:** JUnit5 is the ***latest version*** of the JUnit framework, introducing significant improvements over JUnit 4. It offers a more modern architecture and a flexible programming model.

**JUnit Jupiter (Programming Framework):** Jupiter is the programming model within JUnit5. It provides a more powerful and flexible way to write tests, supporting ***annotations, assertions, and extensions*** to enhance the testing process.

**Lifecycle of Tests:** For each test method a ***new instance*** of the test class is created. This ensures that ***tests are isolated*** from each other and do not share state, reducing the risk of test interference.

**Top Most Important Assertions**

| Assertion                             | Description                          |
|---------------------------------------|--------------------------------------|
| `assertEquals(expected, actual)`      | Compares if two values are equal.    |
| `assertTrue(condition)`               | Checks if a condition is true.       |
| `assertFalse(condition)`              | Checks if a condition is false.      |
| `assertNotNull(object)`               | Verifies that an object is not null. |
| `assertNull(object)`                  | Verifies that an object is null.     |
| `assertArrayEquals(expected, actual)` | Compares arrays for equality.        |

<br>

**assertThrows:** The assertThrows method is used to ***assert that a specific exception*** is thrown during a test. It takes the expected exception type and a lambda expression that triggers the exception. If the exception is thrown as expected, the test passes.

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MathUtilsTest {

    @Test
    void testDivideByZero() {
        MathUtils mathUtils = new MathUtils();

        // Division by 0 should trigger Exception. 
        // If it does, test is passed.
        assertThrows(ArithmeticException.class, () -> {
            mathUtils.divide(5, 0);
        });
    }
}
```
<br>

**Annotations Before and After Code Execution**

| Annotation    | Purpose                                                                                                                                  |
|---------------|------------------------------------------------------------------------------------------------------------------------------------------|
| `@BeforeEach` | Annotating a method with `@BeforeEach` indicates that it should run before each test method in the test class, typically used for setup. |
| `@AfterEach`  | Annotating a method with `@AfterEach` indicates that it should run after each test method, typically used for cleanup.                   |
| `@BeforeAll`  | Annotating a static method with `@BeforeAll` indicates that it should run once before all test methods in the class.                     |

<br>

**Annotations Advanced**

| Annotation                      | Purpose                                                                                                                                        |
|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| `@DisplayName("Test Name")`     | Allows you to provide a custom name for a test method, making test reports more descriptive.                                                   |
| `@Disabled`                     | Used to disable a test or test class, preventing it from being executed.                                                                       |
| `@RepeatedTest`                 | Repeats a test a specified number of times.                                                                                                    |
| `@TestInfo` and `@TestReporter` | Annotations used to access dependency-injected classes that provide information about the test execution, such as display names and reporting. |

<br>

**Nested Test Classes:** This functionality is helpful for organizing and grouping related tests. `@Nested` is used to define nested test classes.


In the following example, there is a test class *CalculatorTest* containing nested test classes (1) AdditionTests and (2) SubtractionTests.

Each nested class focuses on a specific set of test cases related to addition and subtraction operations. This approach helps organize and group related tests together.
```java
import org.junit.jupiter.api.*;

public class CalculatorTest {

    @Nested
    @DisplayName("Addition Tests")
    class AdditionTests {

        @Test
        @DisplayName("Adding two positive numbers")
        void testAddTwoPositiveNumbers() {
            Calculator calculator = new Calculator();
            int result = calculator.add(5, 3);
            assertEquals(8, result);
        }

        @Test
        @DisplayName("Adding a positive and a negative number")
        void testAddPositiveAndNegativeNumber() {
            Calculator calculator = new Calculator();
            int result = calculator.add(7, -2);
            assertEquals(5, result);
        }
    }

    @Nested
    @DisplayName("Subtraction Tests")
    class SubtractionTests {

        @Test
        @DisplayName("Subtracting two positive numbers")
        void testSubtractTwoPositiveNumbers() {
            Calculator calculator = new Calculator();
            int result = calculator.subtract(10, 3);
            assertEquals(7, result);
        }

        @Test
        @DisplayName("Subtracting a negative number from a positive number")
        void testSubtractNegativeFromPositive() {
            Calculator calculator = new Calculator();
            int result = calculator.subtract(5, -2);
            assertEquals(7, result);
        }
    }
}
```

## Mockito
**Problem to Solve - Dependencies:**  How to test Spring applications, especially when dealing with dependencies and external services?

**Solution - Mocking:** Mock dependencies and abstract their functionality without calling them.

### About Mockito
**Definition:** Mockito is a mocking framework in the context of unit testing Spring applications. It allows developers to create mock objects and simulate the behavior of dependencies or external services. 

**Mocking Objects & Syntax**

| **Type** | **Explanation**                                    | **Use Case**                                                                                                                   |
|----------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Mock** | Mocking Instances (Constructor call)               | Simplest form of mocking object. It's a nullified version of the class (all properties are null)                               |
| **Stub** | Mocking functionality (Method call)                | Specialized mock with predefined responses when calling methods. It always returns the same output regardless of the input.    |
| **Spy**  | Using real implementation and mock certain methods | Hybrid between real instance and mock instance; like a regular class instance, with the ability to stub specific methods calls |

Example:

```java
import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class CalculatorTest {
    @Test
    void testMock() {
        // Create a mock of Database (= dependency which should not be called)
        MyDatabase dbMock = mock(MyDatabase.class);
        Locations locations = new Locations();
        UserService userService = UserService(dbMock, locations); // use mock

        // Test
        assertEquals(locations, userService.getLocations()); // Output: PASS
    }

    @Test
    void testStub() {
        // Create mock
        MyDatabase dbMock = mock(MyDatabase.class);
        Locations locations = new Locations();
        UserService userService = UserService(dbMock, locations); // use mock

        // turn mock into stub
        List<Integer> userNames = Arrays.asList("Olaf", "Tim", "Max");
        when(dbMock.getAllUserNames()).thenReturn(userNames); // stub
                
        // Test 
        assertEquals(3, userService.numberOfUsers()); // Output: PASS
        assertEquals(5, userService.numberOfUsers()); // Output: FAILED
    }

    @Test
    void testSpy() {
        // NO MOCK
        MyDatabase db = new MyDatabase;
        Locations locations = new Locations();
        UserService userService = UserService(db, locations); 
        
        // create SPY
        UserService userServiceSpy = spy(userService);
        
        // stub some methods
        when(userServiceSpy.numberOfUsers()).thenReturn(0));

        // use real impl. of spy and perform tests
        ...
    }
    
}
 ```
<br>

**verify():** This method is used to verify that specific methods of a mock object were called during the execution of a test. It allows you to assert that interactions with the mock occurred as expected. 

Example:
```java
// Create a mock
SomeService someService = mock(SomeService.class);

// Call the method under test
int result = myService.doSomethingWith(someService);

// Verify that a specific method was called with specific arguments
verify(someService).specificMethod("argument");

// Verify that a method was called a specific number of times
verify(someService, times(2)).anotherMethod(anyInt())
```

## Logging with SLF4J
**Problem to Solve - Inconsistency in Logging:** There exist many inconsistencies in Java logging libraries/frameworks. How to create a unified way for logging in Java?

**Solution - Use a Facade:** Provide a unified logging library being able to interact with different logging libraries. 

### SLF4J 

**Definition:** SLF4J (Simple Logging Facade for Java) is a logging framework designed to simplify and standardize the process of logging in Java applications. It serves as a ***facade***, providing a common logging API while allowing the application to choose the actual logging implementation at runtime.

**History:** SLF4J was created to address the challenges and inconsistencies in Java logging frameworks and can work seamlessly with various underlying logging libraries.

**Concepts:**
- **Facade Pattern:** SLF4J follows the facade pattern, offering a single, consistent API for logging across different implementations. This decouples the application code from the specific logging framework being used, improving flexibility and maintainability.


- **Bridging:** SLF4J includes bridge libraries that allow it to work with popular logging frameworks such as Logback, Log4j, and java.util.logging. This means you can choose the most suitable backend implementation while maintaining a consistent API in your application.


- **Markers and MDC:** SLF4J supports features like markers and the Mapped Diagnostic Context (MDC) to enhance logging by attaching additional contextual information to log messages.


**Important Syntax:** SLF4J primarily relies on the following syntax elements:
- **Logger:** A logger instance is obtained using `LoggerFactory.getLogger()` and is used to create log entries.


- **Log Levels:** SLF4J supports different log levels, including `TRACE, DEBUG, INFO, WARN, and ERROR`.


- **Placeholder:** Log messages are created with ***placeholders*** and passed as arguments to the logger. 




**Example Code - Logging:**

Code:
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SLF4JExample {

    private static final Logger logger = LoggerFactory.getLogger(SLF4JExample.class);

    public static void main(String[] args) {
        logger.trace("This is a TRACE level message.");
        logger.debug("This is a DEBUG level message.");
        logger.info("This is an INFO level message.");
        logger.warn("This is a WARNING level message.");
        logger.error("This is an ERROR level message.");

        String name = "John";
        int age = 30;
        logger.info("User {} is {} years old.", name, age);
    }
}
```

Output:
```
13:45:00.123 [main] TRACE com.example.SLF4JExample - This is a TRACE level message.
13:45:00.456 [main] DEBUG com.example.SLF4JExample - This is a DEBUG level message.
13:45:00.789 [main] INFO com.example.SLF4JExample - This is an INFO level message.
13:45:01.012 [main] WARN com.example.SLF4JExample - This is a WARNING level message.
13:45:01.345 [main] ERROR com.example.SLF4JExample - This is an ERROR level message.
13:45:01.678 [main] INFO com.example.SLF4JExample - User John is 30 years old.
```



# Protocols
## MQTT
**Problem to Solve - Unreliable Communication:** Usually when dealing with ***IoT devices*** resources are limited and traditional communication protocols may not be efficient or scalable. How to establish ***efficient and scalable communication*** in such ***resource-constrained environments***?

**Solution - Lightweight Protocol:** Create a lightweight and publish-subscribe protocol with specific features to address the challenges in resource-constrained environments.

### About MQTT
**Definition:** MQTT (Message Queuing Telemetry Transport) is a publish-subscribe messaging protocol designed for efficient and low-overhead communication between devices in constrained or unreliable networks. It is known for its simplicity and lightweight nature.

**History:** MQTT was originally developed by Dr. Andy Stanford-Clark of IBM and Arlen Nipper of Arcom in the late 1990s. It has since become an open standard with various versions. The ***Eclipse Foundation***, an influential open-source organization, has significantly contributed to MQTT's standardization and adoption through initiatives like Eclipse Paho.

**Concepts**
MQTT implements these concepts:
- **Publish-Subscribe Model:** Publishers send messages to topics, and subscribers receive messages from topics they are interested in.


- **Broker:** MQTT/Message Broker is a crucial component that  acts as an intermediary between MQTT clients, enabling the exchange of messages.


- **Last Will and Testament:** It allows clients to specify a "last will" message that is published if the client disconnects unexpectedly.

**Versions**
MQTT has several versions, with versions `3.1.1 (old)` and `5 (new)` being the most widely used.

| Feature                         | MQTT Version 3.1.1 | MQTT Version 5    |
|---------------------------------|--------------------|-------------------|
| Session State                   | No                 | Yes               |
| User Properties                 | No                 | Yes               |
| Reason Codes                    | No                 | Yes               |
| Topic Aliases                   | No                 | Yes               |
| Shared Subscriptions            | No                 | Yes               |
| Quality of Service (QoS) Levels | 0, 1, 2            | 0, 1, 2           |
| Retained Messages               | Yes                | Yes               |
| Last Will and Testament         | Yes                | Yes               |
| Maximum Packet Size             | 256 MB             | 256 MB            |
| Message Expiry Interval         | No                 | Yes               |
| Payload Format Indicator        | No                 | Yes               |
| Subscription Identifiers        | No                 | Yes               |
| Maximum Inflight Messages       | 20                 | Unlimited         |

<br>
<br>

**MQTT in Java Spring**
In Java Spring, MQTT can be integrated using libraries like `Eclipse Paho` to enable MQTT-based communication within Spring applications.


**MQTT when dealing with smart cars**
MQTT can be used to enable communication between various vehicle components, such as sensors, control units, and external systems, allowing them to exchange data and instructions in a lightweight and efficient manner.

